// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Simple Auth API
 *
 * A RESTful API service that handles user authentication including signup, signin, and password reset functionality.
 *
 * API version: 1.0.0
 * Contact: support@example.com
 */

package openapi

import (
	"context"
	"database/sql"
	"errors"
	"net/http"
	"os"
	"time"

	"github.com/PhyuSinKhantAung/go-auth-server/go/database"
	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
)

func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}
	return fallback
}

// AuthenticationAPIService is a service that implements the logic for the AuthenticationAPIServicer
// This service should implement the business logic for every endpoint for the AuthenticationAPI API.
// Include any external packages or services that will be required by this service.
type AuthenticationAPIService struct {
	jwtSecret []byte
	db        *sql.DB
}

// NewAuthenticationAPIService creates a default api service
func NewAuthenticationAPIService() *AuthenticationAPIService {
	database.InitDB()
	return &AuthenticationAPIService{
		jwtSecret: []byte(getEnv("JWT_SECRET", "your-256-bit-secret")),
		db:        database.GetDB(),
	}
}

// SignupPost - User sign up
func (s *AuthenticationAPIService) SignupPost(ctx context.Context, signupPostRequest SignupPostRequest) (ImplResponse, error) {
	// Check if user already exists
	var exists bool
	err := s.db.QueryRowContext(ctx, "SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)", signupPostRequest.Email).Scan(&exists)
	if err != nil {
		return Response(http.StatusInternalServerError, map[string]string{"error": "Database error"}), err
	}
	if exists {
		return Response(http.StatusBadRequest, map[string]string{"error": "Email already registered"}), errors.New("email already registered")
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(signupPostRequest.Password), bcrypt.DefaultCost)
	if err != nil {
		return Response(http.StatusInternalServerError, map[string]string{"error": "Error hashing password"}), err
	}

	// Insert the new user
	_, err = s.db.ExecContext(ctx,
		"INSERT INTO users (email, password_hash) VALUES ($1, $2)",
		signupPostRequest.Email, string(hashedPassword))
	if err != nil {
		return Response(http.StatusInternalServerError, map[string]string{"error": "Error creating user"}), err
	}

	return Response(http.StatusCreated, map[string]string{"message": "User successfully registered"}), nil
}

// SigninPost - User sign in
func (s *AuthenticationAPIService) SigninPost(ctx context.Context, signinPostRequest SigninPostRequest) (ImplResponse, error) {
	var hashedPassword string
	err := s.db.QueryRowContext(ctx,
		"SELECT password_hash FROM users WHERE email = $1",
		signinPostRequest.Email).Scan(&hashedPassword)
	if err == sql.ErrNoRows {
		return Response(http.StatusUnauthorized, map[string]string{"error": "Invalid email or password"}), errors.New("invalid credentials")
	}
	if err != nil {
		return Response(http.StatusInternalServerError, map[string]string{"error": "Database error"}), err
	}

	// Compare passwords
	err = bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(signinPostRequest.Password))
	if err != nil {
		return Response(http.StatusUnauthorized, map[string]string{"error": "Invalid email or password"}), errors.New("invalid credentials")
	}

	// Generate JWT token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"email": signinPostRequest.Email,
		"exp":   time.Now().Add(time.Hour * 24).Unix(), // Token expires in 24 hours
	})

	tokenString, err := token.SignedString(s.jwtSecret)
	if err != nil {
		return Response(http.StatusInternalServerError, map[string]string{"error": "Error generating token"}), err
	}

	return Response(http.StatusOK, SigninPost200Response{Token: tokenString}), nil
}

// ResetPasswordPost - Reset user password
func (s *AuthenticationAPIService) ResetPasswordPost(ctx context.Context, resetPasswordPostRequest ResetPasswordPostRequest) (ImplResponse, error) {
	// Check if user exists
	var exists bool
	err := s.db.QueryRowContext(ctx, "SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)", resetPasswordPostRequest.Email).Scan(&exists)
	if err != nil {
		return Response(http.StatusInternalServerError, map[string]string{"error": "Database error"}), err
	}
	if !exists {
		return Response(http.StatusNotFound, map[string]string{"error": "User not found"}), errors.New("user not found")
	}

	// In a real application, you would:
	// 1. Generate a password reset token
	// 2. Store it in the database with an expiration
	// 3. Send an email to the user with a reset link
	// For this example, we'll just acknowledge that the reset process was initiated

	return Response(http.StatusOK, map[string]string{"message": "Password reset email sent successfully"}), nil
}
